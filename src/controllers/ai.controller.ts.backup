/**
 * SORIVA AI CONTROLLER
 * Created by: Amandeep Singh, Punjab, India
 * Purpose: API endpoints for AI chat functionality
 */

import { Request, Response, NextFunction } from 'express';
import { aiService } from '../services/ai.service';
import { SubscriptionTier } from '../core/ai/providers';

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// REQUEST INTERFACES
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

interface ChatRequestBody {
  message: string;
  conversationHistory?: any[];
  temperature?: number;
  maxTokens?: number;
}

// Custom user type for AI requests
interface AIUser {
  id: string;
  tier: SubscriptionTier;
  email: string;
  name?: string;
  subscriptionPlan?: string;
  planStatus?: string;
}

// Use type intersection instead of interface extension
type AuthenticatedRequest = Request & {
  user?: AIUser;
};

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// AI CONTROLLER CLASS
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

export class AIController {
  /**
   * POST /api/ai/chat
   * Send a chat message (non-streaming)
   */
  async chat(req: AuthenticatedRequest, res: Response, next: NextFunction) {
    try {
      // Validate request
      const { message, conversationHistory, temperature, maxTokens } =
        req.body as ChatRequestBody;

      if (!message || typeof message !== 'string' || message.trim().length === 0) {
        return res.status(400).json({
          success: false,
          error: 'Message is required and must be a non-empty string',
        });
      }

      // Get user tier (from auth middleware)
      const userId = req.user?.id || 'anonymous';
      const tier = req.user?.tier || SubscriptionTier.VIBE_FREE;

      // Execute chat
      const response = await aiService.chat({
        message,
        conversationHistory,
        userId,
        tier,
        temperature,
        maxTokens,
      });

      // Return response
      return res.status(200).json({
        success: true,
        data: response,
      });
    } catch (error) {
      next(error);
    }
  }

  /**
   * POST /api/ai/chat/stream
   * Stream a chat message (Server-Sent Events)
   */
  async streamChat(req: AuthenticatedRequest, res: Response, next: NextFunction) {
    try {
      // Validate request
      const { message, conversationHistory, temperature, maxTokens } =
        req.body as ChatRequestBody;

      if (!message || typeof message !== 'string' || message.trim().length === 0) {
        return res.status(400).json({
          success: false,
          error: 'Message is required',
        });
      }

      // Get user info
      const userId = req.user?.id || 'anonymous';
      const tier = req.user?.tier || SubscriptionTier.VIBE_FREE;

      // Set SSE headers
      res.setHeader('Content-Type', 'text/event-stream');
      res.setHeader('Cache-Control', 'no-cache');
      res.setHeader('Connection', 'keep-alive');

      // Stream response
      await aiService.streamChat({
        message,
        conversationHistory,
        userId,
        tier,
        temperature,
        maxTokens,
        onChunk: (chunk: string) => {
          // Send SSE event
          res.write(`data: ${JSON.stringify({ chunk })}\n\n`);
        },
        onComplete: () => {
          // Send completion event
          res.write(`data: ${JSON.stringify({ done: true })}\n\n`);
          res.end();
        },
        onError: (error: Error) => {
          // Send error event
          res.write(
            `data: ${JSON.stringify({
              error: error.message,
            })}\n\n`
          );
          res.end();
        },
      });
    } catch (error) {
      next(error);
    }
  }

  /**
   * GET /api/ai/suggestions
   * Get conversation suggestions
   */
  async getSuggestions(req: AuthenticatedRequest, res: Response, next: NextFunction) {
    try {
      const { context } = req.query;

      if (!context || typeof context !== 'string') {
        return res.status(400).json({
          success: false,
          error: 'Context is required',
        });
      }

      const tier = req.user?.tier || SubscriptionTier.VIBE_FREE;
      const suggestions = await aiService.getSuggestions(tier, context);

      return res.status(200).json({
        success: true,
        data: { suggestions },
      });
    } catch (error) {
      next(error);
    }
  }

  /**
   * GET /api/ai/tiers
   * Get available subscription tiers
   */
  async getTiers(req: Request, res: Response, next: NextFunction) {
    try {
      const tiers = aiService.getAvailableTiers();
      const tierInfo = tiers.map((tier) => aiService.getTierInfo(tier));

      return res.status(200).json({
        success: true,
        data: tierInfo,
      });
    } catch (error) {
      next(error);
    }
  }

  /**
   * GET /api/ai/stats
   * Get service statistics (admin only)
   */
  async getStats(req: Request, res: Response, next: NextFunction) {
    try {
      const stats = aiService.getStats();

      return res.status(200).json({
        success: true,
        data: stats,
      });
    } catch (error) {
      next(error);
    }
  }

  /**
   * GET /api/ai/health
   * Health check endpoint
   */
  async healthCheck(req: Request, res: Response, next: NextFunction) {
    try {
      const health = await aiService.healthCheck();

      return res.status(health.healthy ? 200 : 503).json({
        success: health.healthy,
        data: health,
      });
    } catch (error) {
      next(error);
    }
  }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// EXPORT CONTROLLER INSTANCE
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

export const aiController = new AIController();