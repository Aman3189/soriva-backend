/**
 * SORIVA Intelligence Layer - Proactive Service (DYNAMIC VERSION)
 * Proactive suggestions generated via LLM, not hardcoded
 * Location: src/services/ai/intelligence/proactive.service.ts
 */
import {
  UserContext,
  ProactiveSuggestion,
  ProactiveMessage,
  HealthReminder,
  CelebrationMessage,
  ProactiveConfig,
  LLMService,
} from './intelligence.types';

export class ProactiveService {
  private config: ProactiveConfig;
  private lastCheckInTime: Map<string, Date>;
  private celebrationsSent: Map<string, Set<string>>;
  private llmService: LLMService;

  constructor(
    llmService: LLMService,
    config?: Partial<ProactiveConfig>
  ) {
    this.llmService = llmService;
    this.config = {
      enableHealthReminders: true,
      enableCelebrations: true,
      idleCheckInHours: 48,
      lateNightHour: 23,
      earlyMorningHour: 6,
      ...config
    };
    this.lastCheckInTime = new Map();
    this.celebrationsSent = new Map();
  }

  /**
   * âœ… NEW METHOD: Generate proactive message (called by orchestrator)
   * This wraps generateSuggestions() and returns the expected ProactiveMessage format
   */
  async generateProactive(
    userId: string,
    context: UserContext
  ): Promise<ProactiveMessage | null> {
    try {
      const suggestions = await this.generateSuggestions(userId, context);
      
      if (suggestions.length === 0) {
        return null;
      }

      // Take the highest priority suggestion
      const topSuggestion = suggestions.sort((a, b) => {
        const priorityOrder = { high: 3, medium: 2, low: 1 };
        return priorityOrder[b.priority] - priorityOrder[a.priority];
      })[0];

      // Convert ProactiveSuggestion to ProactiveMessage
      const proactiveMessage: ProactiveMessage = {
        type: this.mapSuggestionTypeToMessageType(topSuggestion.type),
        message: topSuggestion.message,
        priority: topSuggestion.priority,
        shouldSend: true,
        reason: this.generateReason(topSuggestion),
        metadata: {
          triggerTime: new Date(),
          context: topSuggestion.metadata,
        },
      };

      return proactiveMessage;
    } catch (error) {
      console.error('[ProactiveService] Failed to generate proactive message:', error);
      return null;
    }
  }

  /**
   * Map ProactiveSuggestion type to ProactiveMessageType
   */
  private mapSuggestionTypeToMessageType(
    type: 'idle_checkin' | 'health_reminder' | 'wellness_check' | 'followup'
  ): 'idle_check_in' | 'health_reminder' | 'wellness_check' | 'productivity_tip' | 'celebration' | 'follow_up' | 'encouragement' {
    const typeMap = {
      'idle_checkin': 'idle_check_in' as const,
      'health_reminder': 'health_reminder' as const,
      'wellness_check': 'wellness_check' as const,
      'followup': 'follow_up' as const,
    };
    return typeMap[type] || 'idle_check_in';
  }

  /**
   * Generate reason for proactive message
   */
  private generateReason(suggestion: ProactiveSuggestion): string {
    switch (suggestion.type) {
      case 'idle_checkin':
        return 'User has been idle for extended period';
      case 'health_reminder':
        return suggestion.metadata?.reminderType === 'sleep'
          ? 'Late night activity detected'
          : 'Health check reminder';
      case 'wellness_check':
        return suggestion.metadata?.reason === 'stress_detected'
          ? 'Stress indicators detected'
          : 'Afternoon wellness check';
      case 'followup':
        return `Following up on: ${suggestion.metadata?.previousTopic || 'previous conversation'}`;
      default:
        return 'Proactive engagement';
    }
  }

  /**
   * Generate proactive suggestions based on user context
   */
  async generateSuggestions(
    userId: string,
    context: UserContext
  ): Promise<ProactiveSuggestion[]> {
    const suggestions: ProactiveSuggestion[] = [];

    // Check for idle users
    const idleSuggestion = await this.checkIdleUser(userId, context);
    if (idleSuggestion) suggestions.push(idleSuggestion);

    // Check for late night activity
    const lateNightReminder = await this.checkLateNightActivity(context);
    if (lateNightReminder) suggestions.push(lateNightReminder);

    // Check for wellness opportunities
    const wellnessCheck = await this.generateWellnessCheck(context);
    if (wellnessCheck) suggestions.push(wellnessCheck);

    // Check for follow-up opportunities
    const followUp = await this.generateFollowUp(context);
    if (followUp) suggestions.push(followUp);

    return suggestions;
  }

  /**
   * Check if user has been idle and needs a friendly check-in
   * MESSAGE IS DYNAMICALLY GENERATED BY LLM
   */
  private async checkIdleUser(
    userId: string,
    context: UserContext
  ): Promise<ProactiveSuggestion | null> {
    const lastCheckIn = this.lastCheckInTime.get(userId);
    const now = new Date();

    if (!lastCheckIn) {
      this.lastCheckInTime.set(userId, now);
      return null;
    }

    const hoursSinceLastCheckIn = 
      (now.getTime() - lastCheckIn.getTime()) / (1000 * 60 * 60);

    if (hoursSinceLastCheckIn >= this.config.idleCheckInHours!) {
      this.lastCheckInTime.set(userId, now);

      // DYNAMIC MESSAGE GENERATION
      const prompt = this.buildIdleCheckInPrompt(context, hoursSinceLastCheckIn);
      const message = await this.llmService.generateCompletion(prompt, context);

      return {
        type: 'idle_checkin',
        message,
        priority: 'low',
        timestamp: now
      };
    }

    return null;
  }

  /**
   * Build prompt for idle check-in message
   */
  private buildIdleCheckInPrompt(
    context: UserContext,
    hoursSinceLastCheckIn: number
  ): string {
    return `
You are Soriva, a friendly AI companion. Generate a warm check-in message for a user who hasn't been active for ${Math.round(hoursSinceLastCheckIn)} hours.

User Context:
- Language Preference: ${context.preferredLanguage}
- Last Mood: ${context.emotionalState?.mood || 'unknown'}
- Recent Topics: ${context.recentTopics?.join(', ') || 'none'}
- Communication Style: ${context.communicationStyle || 'casual'}

Guidelines:
- Be genuinely caring and non-intrusive
- Match user's language preference (Hinglish if preferred)
- Keep it brief (1-2 sentences max)
- Sound like a friend, not a bot
- Add appropriate emoji (1-2 only)
- Don't be overly concerned or dramatic

Generate ONLY the message text, no explanations:
`;
  }

  /**
   * Check for late night activity and suggest rest
   * MESSAGE IS DYNAMICALLY GENERATED BY LLM
   */
  private async checkLateNightActivity(
    context: UserContext
  ): Promise<ProactiveSuggestion | null> {
    if (!this.config.enableHealthReminders) return null;

    const currentHour = new Date().getHours();
    let timeCategory: 'late_night' | 'very_early' | null = null;
    let priority: 'medium' | 'high' = 'medium';

    // Late night (11 PM - 2 AM)
    if (currentHour >= this.config.lateNightHour! || currentHour <= 2) {
      timeCategory = 'late_night';
      priority = 'medium';
    }

    // Very early morning (3 AM - 6 AM)
    if (currentHour >= 3 && currentHour < this.config.earlyMorningHour!) {
      timeCategory = 'very_early';
      priority = 'high';
    }

    if (timeCategory) {
      // DYNAMIC MESSAGE GENERATION
      const prompt = this.buildLateNightPrompt(context, currentHour, timeCategory);
      const message = await this.llmService.generateCompletion(prompt, context);

      return {
        type: 'health_reminder',
        message,
        priority,
        timestamp: new Date(),
        metadata: { reminderType: 'sleep', hour: currentHour }
      };
    }

    return null;
  }

  /**
   * Build prompt for late night reminder
   */
  private buildLateNightPrompt(
    context: UserContext,
    currentHour: number,
    timeCategory: 'late_night' | 'very_early'
  ): string {
    return `
You are Soriva, a caring AI companion. Generate a health reminder for a user who is active at ${currentHour}:00 hours.

Time Category: ${timeCategory === 'late_night' ? 'Late Night (11 PM - 2 AM)' : 'Very Early Morning (3 AM - 6 AM)'}

User Context:
- Language Preference: ${context.preferredLanguage}
- Emotional State: ${context.emotionalState?.mood || 'unknown'}
- Communication Style: ${context.communicationStyle || 'casual'}

Guidelines:
- Show genuine concern for their health
- ${timeCategory === 'very_early' ? 'Be more concerned, this is unhealthy timing' : 'Gently suggest rest without being preachy'}
- Match language preference (Hinglish if preferred)
- Sound like a caring friend, not a health app
- Be brief but impactful (1-2 sentences)
- Use 1-2 relevant emojis
- Don't lecture, just remind lovingly

Generate ONLY the message text, no explanations:
`;
  }

  /**
   * Generate wellness checks based on mood and activity
   * MESSAGE IS DYNAMICALLY GENERATED BY LLM
   */
  private async generateWellnessCheck(
    context: UserContext
  ): Promise<ProactiveSuggestion | null> {
    if (!this.config.enableHealthReminders) return null;

    let reason: string | null = null;
    const currentHour = new Date().getHours();

    // Check for stressed mood indicators
    if (context.emotionalState?.mood === 'stressed' || 
        context.emotionalState?.mood === 'anxious') {
      reason = 'stress_detected';
    }

    // Check for afternoon slump (14:00 - 16:00)
    if (currentHour >= 14 && currentHour <= 16) {
      const randomCheck = Math.random();
      if (randomCheck < 0.3) { // 30% chance
        reason = 'afternoon_break';
      }
    }

    if (reason) {
      // DYNAMIC MESSAGE GENERATION
      const prompt = this.buildWellnessCheckPrompt(context, reason, currentHour);
      const message = await this.llmService.generateCompletion(prompt, context);

      return {
        type: 'wellness_check',
        message,
        priority: reason === 'stress_detected' ? 'medium' : 'low',
        timestamp: new Date(),
        metadata: { reason }
      };
    }

    return null;
  }

  /**
   * Build prompt for wellness check
   */
  private buildWellnessCheckPrompt(
    context: UserContext,
    reason: string,
    currentHour: number
  ): string {
    const reasonDescriptions = {
      stress_detected: 'User seems stressed or anxious based on conversation',
      afternoon_break: `It's ${currentHour}:00, typical afternoon slump time`
    };

    return `
You are Soriva, a caring AI companion. Generate a wellness check message.

Situation: ${reasonDescriptions[reason as keyof typeof reasonDescriptions]}

User Context:
- Language Preference: ${context.preferredLanguage}
- Current Mood: ${context.emotionalState?.mood || 'unknown'}
- Stress Level: ${context.emotionalState?.stressLevel || 'unknown'}
- Communication Style: ${context.communicationStyle || 'casual'}

Guidelines:
- Suggest a specific, actionable break (walk, water, stretch, deep breath)
- ${reason === 'stress_detected' ? 'Be empathetic and supportive' : 'Be light and energizing'}
- Match language preference (Hinglish if preferred)
- Sound like a supportive friend
- Keep it brief (1-2 sentences)
- Use 1-2 relevant emojis
- Make it feel natural, not automated

Generate ONLY the message text, no explanations:
`;
  }

  /**
   * Generate follow-up suggestions based on previous interactions
   * MESSAGE IS DYNAMICALLY GENERATED BY LLM
   */
  private async generateFollowUp(
    context: UserContext
  ): Promise<ProactiveSuggestion | null> {
    const recentTopics = context.recentTopics || [];

    if (recentTopics.length > 0) {
      const lastTopic = recentTopics[recentTopics.length - 1];

      // Check if topic needs follow-up
      const taskKeywords = ['deadline', 'task', 'assignment', 'project', 'interview'];
      const needsFollowUp = taskKeywords.some(keyword => 
        lastTopic.toLowerCase().includes(keyword)
      );

      if (needsFollowUp) {
        // DYNAMIC MESSAGE GENERATION
        const prompt = this.buildFollowUpPrompt(context, lastTopic);
        const message = await this.llmService.generateCompletion(prompt, context);

        return {
          type: 'followup',
          message,
          priority: 'low',
          timestamp: new Date(),
          metadata: { previousTopic: lastTopic }
        };
      }
    }

    return null;
  }

  /**
   * Build prompt for follow-up message
   */
  private buildFollowUpPrompt(
    context: UserContext,
    previousTopic: string
  ): string {
    return `
You are Soriva, a friendly AI companion. Generate a follow-up message about a previous conversation topic.

Previous Topic: "${previousTopic}"

User Context:
- Language Preference: ${context.preferredLanguage}
- Communication Style: ${context.communicationStyle || 'casual'}

Guidelines:
- Ask about the topic naturally, like a friend would
- Match language preference (Hinglish if preferred)
- Be genuinely interested, not pushy
- Keep it conversational (1 sentence)
- Add 1-2 relevant emojis
- Make it feel like you genuinely care about the outcome

Generate ONLY the message text, no explanations:
`;
  }

  /**
   * Generate celebration messages for milestones
   * MESSAGE IS DYNAMICALLY GENERATED BY LLM
   */
  async generateCelebration(
    userId: string,
    milestone: string,
    context: UserContext
  ): Promise<CelebrationMessage | null> {
    if (!this.config.enableCelebrations) return null;

    // Check if already celebrated
    if (!this.celebrationsSent.has(userId)) {
      this.celebrationsSent.set(userId, new Set());
    }

    const userCelebrations = this.celebrationsSent.get(userId)!;
    if (userCelebrations.has(milestone)) {
      return null;
    }

    userCelebrations.add(milestone);

    // DYNAMIC MESSAGE GENERATION
    const prompt = this.buildCelebrationPrompt(context, milestone);
    const message = await this.llmService.generateCompletion(prompt, context);

    // Extract emoji from message (LLM will include it)
    const emojiMatch = message.match(/[\u{1F300}-\u{1F9FF}]/u);
    const emoji = emojiMatch ? emojiMatch[0] : 'ðŸŽ‰';

    return {
      milestone,
      message,
      emoji,
      timestamp: new Date()
    };
  }

  /**
   * Build prompt for celebration message
   */
  private buildCelebrationPrompt(
    context: UserContext,
    milestone: string
  ): string {
    return `
You are Soriva, an enthusiastic AI companion. Generate a celebration message for a user achievement.

Achievement: ${milestone}

User Context:
- Language Preference: ${context.preferredLanguage}
- Communication Style: ${context.communicationStyle || 'casual'}

Guidelines:
- Be genuinely excited and proud
- Match language preference (Hinglish if preferred - use words like "Shabaash!", "Waah!", "Zabardast!")
- Sound like a friend celebrating with them
- Keep it energetic but authentic (1-2 sentences)
- Include 2-3 celebration emojis
- Make it feel personal, not generic

Generate ONLY the message text with emojis, no explanations:
`;
  }

  /**
   * Generate health reminder based on time and activity
   * MESSAGE IS DYNAMICALLY GENERATED BY LLM
   */
  async generateHealthReminder(context: UserContext): Promise<HealthReminder | null> {
    if (!this.config.enableHealthReminders) return null;

    const currentHour = new Date().getHours();
    let reminderType: 'hydration' | 'eye_rest' | 'posture' | null = null;
    let priority: 'low' | 'medium' = 'low';

    // Determine reminder type based on time
    if (currentHour >= 10 && currentHour <= 20) {
      reminderType = 'hydration';
    } else if (currentHour >= 9 && currentHour <= 18) {
      reminderType = 'eye_rest';
      priority = 'medium';
    } else if (currentHour >= 11 && currentHour <= 17) {
      reminderType = 'posture';
    }

    if (reminderType) {
      // DYNAMIC MESSAGE GENERATION
      const prompt = this.buildHealthReminderPrompt(context, reminderType);
      const message = await this.llmService.generateCompletion(prompt, context);

      return {
        type: reminderType,
        message,
        priority,
        timestamp: new Date()
      };
    }

    return null;
  }

  /**
   * Build prompt for health reminder
   */
  private buildHealthReminderPrompt(
    context: UserContext,
    reminderType: 'hydration' | 'eye_rest' | 'posture'
  ): string {
    const reminderDetails = {
      hydration: 'Remind user to drink water / stay hydrated',
      eye_rest: 'Remind user to rest their eyes from screen (20-20-20 rule)',
      posture: 'Remind user to check and correct their sitting posture'
    };

    return `
You are Soriva, a caring AI companion. Generate a health reminder.

Reminder Type: ${reminderDetails[reminderType]}

User Context:
- Language Preference: ${context.preferredLanguage}
- Communication Style: ${context.communicationStyle || 'casual'}

Guidelines:
- Be caring but not preachy
- Match language preference (Hinglish if preferred)
- Sound like a friend who cares
- Keep it brief (1 sentence)
- Include 1-2 relevant emojis
- ${reminderType === 'eye_rest' ? 'Mention the 20-20-20 rule if using English, or "20 sec ke liye 20 feet door dekho" in Hinglish' : ''}

Generate ONLY the message text, no explanations:
`;
  }

  /**
   * Clear celebration history for a user
   */
  clearCelebrations(userId: string): void {
    this.celebrationsSent.delete(userId);
  }

  /**
   * Update configuration
   */
  updateConfig(config: Partial<ProactiveConfig>): void {
    this.config = { ...this.config, ...config };
  }

  /**
   * Get current configuration
   */
  getConfig(): ProactiveConfig {
    return { ...this.config };
  }
}

export default ProactiveService;